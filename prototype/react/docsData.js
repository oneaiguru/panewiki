// Auto-generated by scripts/generateDocsData.js
export const DOCS = {
  "ADR-009 Home Position Navigation": {
    id: "ADR-009 Home Position Navigation",
    title: `ADR-009: Home Position Navigation`,
    filename: "ADR-009 Home Position Navigation.md",
    links: ["ADR003FixedThreePaneViewport","ADR004ComputedScrollPosition","ADR005ReactHooksState","DesignDecisionsLog"],
    content: `# ADR-009: Home Position Navigation

**Status**: Accepted

## Decision

\`home\` is the canonical entry point.
Home button always returns to \`home\`.
Home key (keyboard) jumps to start.

## Why

- Users need an entry point (familiar mental model)
- Escape route if lost in navigation
- Single consistent reference point
- Matches browser "Home" behavior

## Navigation Pattern

\`\`\`
From any position:
  Press Home button → currentIndex = 0
  Press Home key   → currentIndex = 0
  Result: Back at \`home\`
\`\`\`

## Benefits

✓ Users never truly lost
✓ Clear entry point
✓ Reduces disorientation
✓ Familiar from web browsers

## Implementation

\`\`\`javascript
const handleHome = () => {
  setCurrentIndex(0)
  // history stays intact
}

// Keyboard listener
if (event.key === 'Home') {
  handleHome()
}
\`\`\`

## State Behavior

- **Home button**: Navbar button labeled "Home"
- **Keyboard**: Home key triggers handleHome()
- **History**: Preserved (can jump back to where you were)
- **Breadcrumb**: Shows "1 / N" when at home

## Related

- [ADR003FixedThreePaneViewport](ADR003FixedThreePaneViewport)
- [ADR004ComputedScrollPosition](ADR004ComputedScrollPosition)
- [ADR005ReactHooksState](ADR005ReactHooksState)

See: [DesignDecisionsLog](DesignDecisionsLog)
`
  },
  "ADR001HistoryBasedNavigation": {
    id: "ADR001HistoryBasedNavigation",
    title: `ADR-001: History-Based Navigation`,
    filename: "ADR001HistoryBasedNavigation.md",
    links: ["ADR002AppendOnlyHistory","ADR007AppendForwardNavigation","DesignDecisionsLog"],
    content: `# ADR-001: History-Based Navigation

**Status**: Accepted

## Decision

Use graph-based navigation (any node → any node),
not tree hierarchy.

## Why

- Matches browser history mental model
- Enables cross-level links
- Users can navigate freely
- Allows loops and revisits

## The Pattern

\`\`\`
User navigates: Home → Frontend → React
               ↓
History: [Home, Frontend, React]
               ↓
User clicks link to API (cross-level)
               ↓
History: [Home, Frontend, React, API]
\`\`\`

## Benefits

✓ Unlimited flexibility
✓ Intuitive navigation
✓ Real-world content structure

## Trade-offs

✗ Requires careful link design
✗ Users might get "lost"
✗ Mitigated by breadcrumb + jump buttons

## Related

- [ADR002AppendOnlyHistory](ADR002AppendOnlyHistory)
- [ADR007AppendForwardNavigation](ADR007AppendForwardNavigation)

See: [DesignDecisionsLog](DesignDecisionsLog)
`
  },
  "ADR002AppendOnlyHistory": {
    id: "ADR002AppendOnlyHistory",
    title: `ADR-002: Append-Only History`,
    filename: "ADR002AppendOnlyHistory.md",
    links: ["ADR001HistoryBasedNavigation","ADR007AppendForwardNavigation","ConstraintsAndAssumptions"],
    content: `# ADR-002: Append-Only History

**Status**: Accepted

## Decision

History array only grows. Never truncate or prune.

## Why

- Simpler state management
- Users can always jump back
- Matches browser behavior mostly
- No edge cases

## Example

\`\`\`
Navigate: 1 → 2 → 3 → 4 → 5
Back 2 times (now at position 3)
Click link to X
               ↓
Result: history = [1, 2, 3, 4, 5, X]
        can still jump to 4 or 5
\`\`\`

## Benefits

✓ Simple logic (just push)
✓ Nothing is ever lost
✓ Deterministic behavior

## Trade-offs

✗ History grows with usage
✗ No code reuse between versions

## Mitigation

Memory impact minimal (~1-2KB per item).
Can add virtual scrolling in Phase 2.

## Related

- [ADR001HistoryBasedNavigation](ADR001HistoryBasedNavigation)
- [ADR007AppendForwardNavigation](ADR007AppendForwardNavigation)

See: [ConstraintsAndAssumptions](ConstraintsAndAssumptions)
`
  },
  "ADR003FixedThreePaneViewport": {
    id: "ADR003FixedThreePaneViewport",
    title: `ADR-003: Fixed 3-Pane Viewport`,
    filename: "ADR003FixedThreePaneViewport.md",
    links: ["ADR004ComputedScrollPosition","ImplementationRoadmap","DesignDecisionsLog"],
    content: `# ADR-003: Fixed 3-Pane Viewport

**Status**: Accepted

## Decision

Show exactly 3 panes (400px each) in 1200px viewport.
Strip grows infinitely as user navigates.

## Why

- Users see context (past + current + next)
- Spatial memory (left = past, right = future)
- Scalable with history growth
- Elegant visual transitions

## Geometry

\`\`\`
Pane: 400px wide
Viewport: 1200px (3 panes visible)
Strip: history.length × 400px

At position 0: show panes 0, 1, 2
At position 5: show panes 3, 4, 5
At position 50: show panes 48, 49, 50
\`\`\`

## Benefits

✓ Intuitive navigation
✓ Always shows relationships
✓ Desktop-friendly

## Trade-offs

✗ Not mobile-friendly (deferred)
✗ PDF width constrained to 400px

## Related

- [ADR004ComputedScrollPosition](ADR004ComputedScrollPosition)
- [ImplementationRoadmap](ImplementationRoadmap)

See: [DesignDecisionsLog](DesignDecisionsLog)
`
  },
  "ADR004ComputedScrollPosition": {
    id: "ADR004ComputedScrollPosition",
    title: `ADR-004: Computed ScrollPosition`,
    filename: "ADR004ComputedScrollPosition.md",
    links: ["ADR003FixedThreePaneViewport","DesignDecisionsLog"],
    content: `# ADR-004: Computed ScrollPosition

**Status**: Accepted

## Decision

ScrollLeft is always calculated from currentIndex.
Users cannot manually scroll.

## Formula

\`\`\`
scrollLeft = max(0, (currentIndex - 2) * 400)

Position 0:  scrollLeft = 0
Position 5:  scrollLeft = 1200
Position 50: scrollLeft = 19200
\`\`\`

## Why

- Deterministic position (always correct)
- No state conflicts
- Automatic smooth animation
- Prevents scrolling bugs

## Implementation

\`\`\`javascript
useEffect(() => {
  container.scrollTo({
    left: scrollLeft,
    behavior: 'smooth'  // 300ms
  });
}, [scrollLeft]);
\`\`\`

## Benefits

✓ Consistent positioning
✓ No manual override conflicts
✓ Easy to test

## Trade-offs

✗ Users can't manually scroll to explore
✗ Less familiar than typical scrollbars

## Mitigation

Jump buttons + keyboard shortcuts enable exploration.

## Related

- [ADR003FixedThreePaneViewport](ADR003FixedThreePaneViewport)
- [DesignDecisionsLog](DesignDecisionsLog)
`
  },
  "ADR005ReactHooksState": {
    id: "ADR005ReactHooksState",
    title: `ADR-005: React Hooks State`,
    filename: "ADR005ReactHooksState.md",
    links: ["ADR002AppendOnlyHistory","ADR008PureStatelessRenderer"],
    content: `# ADR-005: React Hooks State

**Status**: Accepted

## Decision

Use local useState for 2 variables.
No Redux, Context API, or other library.

## Why

- Simple for 2 state variables
- Minimal boilerplate
- Fast iteration
- No learning curve

## Implementation

\`\`\`javascript
const [history, setHistory] = useState([...])
const [currentIndex, setCurrentIndex] = useState(0)

// Derived (calculated, not stored):
const scrollLeft = max(0, (currentIndex - 2) * 400)
const visiblePanes = history.slice(...)
\`\`\`

## Handlers

All in App.jsx:

\`\`\`javascript
const handleClickLink = (id) => {
  setHistory(prev => [...prev, DOCS[id]])
  setCurrentIndex(history.length)
}

const handleBack = () => {
  setCurrentIndex(prev => prev - 1)
}
\`\`\`

## Benefits

✓ Simple and readable
✓ No framework overhead
✓ Standard React patterns

## Trade-offs

✗ Not scalable to large apps
✗ Prop drilling if many components

## Scaling Path

Phase 2: extract custom hook if needed
Phase 3: move to Redux/Zustand if needed

## Related

- [ADR002AppendOnlyHistory](ADR002AppendOnlyHistory)
- [ADR008PureStatelessRenderer](ADR008PureStatelessRenderer)
`
  },
  "ADR006MockPDFsNotRealRendering": {
    id: "ADR006MockPDFsNotRealRendering",
    title: `ADR-006: Mock PDFs (Not Real Rendering)`,
    filename: "ADR006MockPDFsNotRealRendering.md",
    links: ["ADR008PureStatelessRenderer","MockDataTemplate","ImplementationRoadmap"],
    content: `# ADR-006: Mock PDFs (Not Real Rendering)

**Status**: Accepted

## Decision

Use colored placeholder boxes instead of real PDFs.

## Why

- Simplifies prototype (no PDF library)
- Focuses on navigation UX, not rendering
- Data structure ready for Phase 2+
- Easy to swap for real PDFs later

## What It Looks Like

\`\`\`
┌─────────────────────┐
│ [PDF Preview: Name] │
│                     │
│  (Colored box)      │
│                     │
└─────────────────────┘
\`\`\`

## Benefits

✓ Fast to implement
✓ No external dependencies
✓ Proves navigation works

## Trade-offs

✗ Not realistic
✗ Can't validate PDF layout
✗ No actual diagram content

## Migration to Real PDFs (Phase 2+)

Same data model, different renderer:

\`\`\`javascript
// Phase 1 (mock):
<MockPDFBox node={node} />

// Phase 2+ (real):
<PDFRenderer node={node} />
\`\`\`

Same navigation code, different rendering.

## Related

- [ADR008PureStatelessRenderer](ADR008PureStatelessRenderer)
- [MockDataTemplate](MockDataTemplate)

See: [ImplementationRoadmap](ImplementationRoadmap)
`
  },
  "ADR007AppendForwardNavigation": {
    id: "ADR007AppendForwardNavigation",
    title: `ADR-007: Append-Forward Navigation`,
    filename: "ADR007AppendForwardNavigation.md",
    links: ["ADR001HistoryBasedNavigation","ADR002AppendOnlyHistory","DesignDecisionsLog"],
    content: `# ADR-007: Append-Forward Navigation

**Status**: Accepted

## Decision

Always append navigation to history. No branch tracking.

## Why

- Simpler than branching (Git-style)
- Matches browser behavior
- Linear is easier to understand
- Deterministic (same rule always)

## Example

\`\`\`
Navigate: 1 → 2 → 3 → 4 → 5
Back to position 2
Click link to X
               ↓
Result: history = [1, 2, 3, 4, 5, X]
Can still jump to 3, 4, or 5
\`\`\`

## The Pattern

Navigate forward always = append to end.

No "branches" or alternative paths.

## Benefits

✓ Simple mental model
✓ Familiar to users
✓ No complex state tracking

## Trade-offs

✗ Can't show "alternate timelines"
✗ Old paths get buried (but still accessible)

## Mitigation

Jump buttons let users revisit earlier positions.
Breadcrumb shows where they are.

## Related

- [ADR001HistoryBasedNavigation](ADR001HistoryBasedNavigation)
- [ADR002AppendOnlyHistory](ADR002AppendOnlyHistory)

See: [DesignDecisionsLog](DesignDecisionsLog)
`
  },
  "ADR008PureStatelessRenderer": {
    id: "ADR008PureStatelessRenderer",
    title: `ADR-008: Pure Stateless Renderer`,
    filename: "ADR008PureStatelessRenderer.md",
    links: ["ADR001HistoryBasedNavigation","ADR005ReactHooksState","ImplementationRoadmap"],
    content: `# ADR-008: Pure Stateless Renderer

**Status**: Accepted

## Decision

Navigation Layer owns ALL state.
Renderer Layer is pure function (no internal state).

## Why

- Pattern replicates across all platforms
- Each version can use native idioms
- Navigation testable without rendering
- Renderers swappable

## The Pattern

\`\`\`
Navigation owns:
- currentIndex
- history[]
- handleClickLink()

Renderer receives:
- node (document)
- onClickLink callback

Renderer returns:
- Visual output (JSX, string, PDF, etc.)
\`\`\`

## V1 to V2+ Scaling

\`\`\`
V1 (React):      render(node) → JSX
V2 (Terminal):   render(node) → ANSI string
V3 (PDF):        render(node) → PDF page
V4 (Editor):     render(node) → Editor component
\`\`\`

Same navigation, different renderers.

## Benefits

✓ Platform independence
✓ Pattern is obvious
✓ Easy to reimplement in V2+

## Trade-offs

✗ No actual code reuse across platforms
✗ Each version reimplements pattern

## Related

- [ADR001HistoryBasedNavigation](ADR001HistoryBasedNavigation)
- [ADR005ReactHooksState](ADR005ReactHooksState)
- [ImplementationRoadmap](ImplementationRoadmap)
`
  },
  "ConstraintsAndAssumptions": {
    id: "ConstraintsAndAssumptions",
    title: `Constraints & Assumptions`,
    filename: "ConstraintsAndAssumptions.md",
    links: ["MockDataTemplate"],
    content: `# Constraints & Assumptions

## Technology Stack

- Framework: React (hooks)
- Styling: CSS (plain)
- Browser: Modern (Chrome, Firefox, Safari, Edge)
- JavaScript: ES6+

## What's NOT Included

✗ Real PDF rendering
✗ Data persistence
✗ Multi-user sync
✗ Virtual scrolling (Phase 2)
✗ Search/filter
✗ Accessibility (Phase 2)
✗ Mobile optimization (Phase 2)

## Hard Constraints

- Viewport width: 1200px (fixed)
- Pane width: 400px (fixed)
- Visible panes: exactly 3
- Strip width: history.length × 400px
- History: append-only (never truncate)
- ScrollLeft: computed (user can't override)
- No frontmatter in markdown files

## Tested Limits

- History length: smooth up to 100 items
- DOM nodes: 1:1 with history length
- Re-renders: React re-renders full app

## Data Constraints

- Node IDs: unique strings (semantic CamelCase)
- Links: point to valid node IDs
- Content: markdown (no custom format)
- Mock data: 32 hardcoded nodes

## Assumptions

- Single user session
- No page reloads (session-based)
- Continuous mouse/keyboard
- Desktop browser only

See: [MockDataTemplate](MockDataTemplate)
`
  },
  "DefinitionDictionary": {
    id: "DefinitionDictionary",
    title: `Definition Dictionary`,
    filename: "DefinitionDictionary.md",
    links: ["DesignDecisionsLog"],
    content: `# Definition Dictionary

## Core Terms

**History**: Array of visited documents. Grows indefinitely.

**CurrentIndex**: Position in history (0-based). User's location.

**Breadcrumb**: Text showing last 3 visible panes. Navigation context.

**Pane**: Individual document display (400px wide).

**Viewport**: Visible window (1200px). Shows 3 panes always.

**Strip**: Horizontal container (full width = history length × 400px).

## Navigation Terms

**Jump Button**: Button to jump to earlier position instantly.

**Navigate Forward**: Click link → append to history.

**Navigate Back**: Decrement currentIndex (history unchanged).

**Leaf Node**: Document with no outgoing links.

**Self-Reference**: Link pointing to same document.

## State Terms

**Rendered Panes**: 3 panes currently visible in viewport.

**Hidden Ancestors**: Earlier panes (off-screen left).

**Visible StartIndex**: Index of leftmost visible pane.

**ScrollLeft**: CSS position of viewport scroll (computed).

**Depth**: Current position (currentIndex + 1 / total length).

See: [DesignDecisionsLog](DesignDecisionsLog)
`
  },
  "DesignDecisionsLog": {
    id: "DesignDecisionsLog",
    title: `Design Decisions Log`,
    filename: "DesignDecisionsLog.md",
    links: ["ADR001HistoryBasedNavigation","ADR002AppendOnlyHistory","ADR003FixedThreePaneViewport","ADR004ComputedScrollPosition","ADR005ReactHooksState","ADR006MockPDFsNotRealRendering","ADR007AppendForwardNavigation","ADR008PureStatelessRenderer","ConstraintsAndAssumptions","DefinitionDictionary","MockDataTemplate"],
    content: `# Design Decisions Log

## Decision #1: Breadcrumb Shows Visible Panes Only
Breadcrumb displays only 3 currently visible panes, not full history.
Status: Locked

## Decision #2: Never Truncate History, Always Append
History array only grows; never removes or prunes items.
Status: Locked

## Decision #3: Show All Jump Buttons (No Truncation)
Jump buttons for ALL hidden ancestor panes, not truncated.
Status: Locked

## Decision #4: Right Arrow on Leaf Nodes = No-Op
If rightmost pane has no links, keyboard right-arrow does nothing.
Status: Locked

## Decision #5: Graph-Based Navigation (Any Node → Any Node)
Nodes can link to any other node; no parent-child hierarchy.
Status: Locked

## Decision #6: Initial State = Homepage Only
App starts with history = [HomepageNode], currentIndex = 0.
Status: Locked

## Decision #7: Pane Width = 400px (A4 at ~33%)
Each pane 400px, viewport 1200px = 3 panes visible.
Status: Locked

## Decision #8: Scroll Animation = 300ms Smooth
ScrollLeft updates animate over 300ms via CSS smooth scroll.
Status: Locked

## Decision #9: No Performance Optimization in Prototype
Render all panes as DOM nodes; no virtual scrolling.
Status: Deferred to Phase 2

## Decision #10: Mobile Behavior Deferred
No mobile optimization in prototype; single-pane deferred.
Status: Deferred to Phase 2

## Decision #11: No React Memoization
Components don't use React.memo or useMemo in prototype.
Status: Deferred to Phase 2

## Decision #12: Mock PDFs = Colored Boxes
Show placeholder boxes with diagram name instead of real PDFs.
Status: Prototype only

## Decision #13: One-Way Navigation History
History only grows forward; no branching like Git.
Status: Locked

## Decision #14: Keyboard Shortcuts Enabled by Default
← (back), → (forward), Home work globally.
Status: Locked

## Decision #15: Home Position = \`home\`
Users can jump to \`home\` via Home button or keyboard. History is preserved; only currentIndex resets to 0.
Status: Locked

## Related Architecture Decisions

- [ADR001HistoryBasedNavigation](ADR001HistoryBasedNavigation)
- [ADR002AppendOnlyHistory](ADR002AppendOnlyHistory)
- [ADR003FixedThreePaneViewport](ADR003FixedThreePaneViewport)
- [ADR004ComputedScrollPosition](ADR004ComputedScrollPosition)
- [ADR005ReactHooksState](ADR005ReactHooksState)
- [ADR006MockPDFsNotRealRendering](ADR006MockPDFsNotRealRendering)
- [ADR007AppendForwardNavigation](ADR007AppendForwardNavigation)
- [ADR008PureStatelessRenderer](ADR008PureStatelessRenderer)
See: [ConstraintsAndAssumptions](ConstraintsAndAssumptions)
 
## Supporting Documentation

- [DefinitionDictionary](DefinitionDictionary)
- [ConstraintsAndAssumptions](ConstraintsAndAssumptions)
- [MockDataTemplate](MockDataTemplate)
`
  },
  "ImplementationRoadmap": {
    id: "ImplementationRoadmap",
    title: `Implementation Roadmap (V1 Prototype)`,
    filename: "ImplementationRoadmap.md",
    links: ["home"],
    content: `# Implementation Roadmap (V1 Prototype)

## File Structure

\`\`\`
src/
├─ App.jsx
├─ App.css
├─ components/
│  ├─ NavigationBar.jsx
│  ├─ ScrollContainer.jsx
│  ├─ PaneStrip.jsx
│  ├─ Pane.jsx
│  └─ RelatedDiagrams.jsx
├─ hooks/
│  └─ useNavigation.js
└─ utils/
   └─ scrollCalculations.js
\`\`\`

## Component Hierarchy

\`\`\`
App
├─ NavigationBar
│  ├─ BreadcrumbDisplay
│  ├─ AncestorJumpButtons
│  └─ BackControls
└─ ScrollContainer
   └─ PaneStrip
      └─ Pane[] (map history)
         ├─ PaneHeader
         ├─ MockPDFPreview
         └─ RelatedDiagrams
\`\`\`

## Phase 1: Foundation (State + Math)

Create: useNavigation hook, scroll calculations
What works: State updates, scroll position math

## Phase 2: Layout (Navigation Bar + Viewport)

Create: NavigationBar, ScrollContainer
What works: UI appears, buttons visible

## Phase 3: Panes (Individual Displays)

Create: PaneStrip, Pane, RelatedDiagrams
What works: Forward/back navigation works

## Phase 4: Polish (Animation + Keyboard)

Create: Smooth scroll, keyboard shortcuts
What works: Everything feels responsive

## Success Criteria

All 4 phases complete:
✓ State management works
✓ Navigation works (forward, back, jump)
✓ UI renders correctly
✓ Smooth animations
✓ Keyboard shortcuts functional

See: [home](home)
`
  },
  "MasterIssueChecklist": {
    id: "MasterIssueChecklist",
    title: `Master Issue Checklist`,
    filename: "MasterIssueChecklist.md",
    links: ["ImplementationRoadmap","SectionsStatusTracker","DesignDecisionsLog"],
    content: `# Master Issue Checklist

**Total**: 18 issues

## Critical

- Issue #1: 3-pane viewport exactly 3 panes
- Issue #4: History never truncates
- Issue #5: Breadcrumb shows visible only

## High Priority

- Issue #6: Navigation bar displays
- Issue #7: Jump buttons show all
- Issue #14: No React memoization

## Medium Priority

- Issue #3: Right arrow on leaf = no-op
- Issue #8: 300ms scroll animation
- Issue #12: Handle 100+ items

## Low Priority

- Issue #2: Keyboard shortcuts
- Issue #9: Mobile support deferred
- Issue #10: Advanced features deferred

## Summary

✓ 18 issues identified
✓ 4 priority levels
→ Ready for implementation

See: [ImplementationRoadmap](ImplementationRoadmap)
See: [SectionsStatusTracker](SectionsStatusTracker)
See: [DesignDecisionsLog](DesignDecisionsLog)
`
  },
  "MockDataTemplate": {
    id: "MockDataTemplate",
    title: `Mock Data Template`,
    filename: "MockDataTemplate.md",
    links: ["ImplementationRoadmap","ConstraintsAndAssumptions"],
    content: `# Mock Data Template

## Data Structure

Each node:
\`\`\`javascript
{
  id: "react",
  name: "React Components",
  links: ["comp-library", "custom-hooks"]
}
\`\`\`

## The 32 Nodes (Interconnected Graph)

Level 1: home
Level 2: frontend, backend, random-deep
Level 3: react, state-mgmt, api-services, database
Level 4: comp-library, custom-hooks, redux-store, context-api
Level 4: rest-endpoints, graphql-layer, sql-db, cache-layer
Level 5: button-comps, form-comps, useauth-hook, usefetch-hook
Level 5: redux-actions, redux-reducers, auth-context, theme-context
Level 5: user-endpoints, post-endpoints, graphql-schema, graphql-resolvers
Level 5: user-schema, post-schema, redis-config, ttl-strategy

## Example Node with Links

\`\`\`javascript
"react": {
  id: "react",
  name: "React Components",
  links: [
    "comp-library",      // child
    "custom-hooks",      // sibling
    "frontend",          // parent
    "home"               // cross-level
  ]
}
\`\`\`

## Link Characteristics

- Forward: to "deeper" nodes (react → button-comps)
- Backward: to "shallower" nodes (button-comps → react)
- Cross-level: skipping levels (api-services → home)
- Self-reference: node links to itself (random-deep)
- Cycles: A→B→C→A loops allowed

## Statistics

- Total nodes: 32
- Leaf nodes: 17 (no children)
- Avg links per node: 2-3
- Max links: 4 (home, react)

See: [ImplementationRoadmap](ImplementationRoadmap)
See: [ConstraintsAndAssumptions](ConstraintsAndAssumptions)
`
  },
  "SectionsStatusTracker": {
    id: "SectionsStatusTracker",
    title: `Sections Status Tracker`,
    filename: "SectionsStatusTracker.md",
    links: ["MasterIssueChecklist","home"],
    content: `# Sections Status Tracker

## Completed

✓ Section 1: Core Concept
✓ Section 2: Requirements Overview

## In Progress

→ Section 3: Navigation Logic
→ Section 4: State Management
→ Section 5: Scroll Behavior

## To Do

□ Section 6: Data Structure
□ Section 7: Component Architecture
□ Section 8: Testing Strategy
□ Section 9: Mock Data
□ Section 10: Examples
□ Section 11: Success Criteria
□ Section 12: Phase 2 Notes

## Progress

2 Complete / 11 To Do

Next: Write Sections 3-5

See: [MasterIssueChecklist](MasterIssueChecklist)
See: [home](home)
`
  },
  "home": {
    id: "home",
    title: `Home (Staged Writing Plan)`,
    filename: "home.md",
    links: ["MasterIssueChecklist","DesignDecisionsLog"],
    content: `# Home (Staged Writing Plan)

## Stage 1: Foundation

✓ Sections 1-2: Overview + Requirements
→ Define all ADRs (001-008)
→ Lock core architecture
→ Create supporting artifacts

## Stage 2: Verification

→ Write Sections 3-5: Navigation, State, Scroll
→ Write Section: Data & Content Structure
→ Verify all sections reference ADRs
→ Cross-check constraints

## Stage 3: Specification

→ Write Sections 6-7: Components, Architecture
→ Write Section: Examples + Mock Data
→ Write Section: Testing Strategy
→ Add success criteria

## Stage 4: Completion

→ Sections 8-12: Details, Phase 2 notes
→ Final review + consistency check
→ Ready for implementation
→ Lock all decisions

## Acceptance Criteria

Each stage complete when:
- All sections written
- Cross-references working
- No contradictions with ADRs
- Approved for next stage

See: [MasterIssueChecklist](MasterIssueChecklist)
See: [DesignDecisionsLog](DesignDecisionsLog)
`
  }
};

export const DOC_IDS = Object.keys(DOCS);
export const START_DOC_ID = "MasterIssueChecklist";
